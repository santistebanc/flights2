<!-- # Flight Scraping Project - Essential Rules

## Core Principles

- **Research First**: Always research existing solutions before implementing
- **Debug-First**: Generate debug files for all operations, analyze before fixing
- **Test Immediately**: Run tests after each change, fix failures before proceeding
- **Document Everything**: JSDoc for all functions, track decisions and research
- **Clean Up**: Remove debug files and artifacts after completion

## Code Quality

- Use explicit TypeScript types, avoid `any`
- Modular design with single responsibility
- Comprehensive error handling with context
- ES modules, native JS methods over Node.js modules
- Lightweight dependencies, prefer well-maintained libraries

## Scraping Best Practices

- Rate limiting and polite crawling
- Retry logic with exponential backoff
- Multiple element finding strategies
- Graceful degradation for missing elements
- Centralized configuration and structured logging

## Web Scraping & Session Management

### Critical Scraping Logic Requirements

#### Kiwi Scraper Flow (STRICT REQUIREMENTS)

1. **Initial Page Request**: Fetch initial page, extract session cookie and tokens from last `<script>` tag
2. **Cookie Management**: Use cookie from each response for the next request (update cookies after each response)
3. **Request Construction**: Include extracted tokens in request body, session cookie in headers
4. **Required Tokens**: Must extract `_token`, from initial page

#### Sky Scraper Flow (STRICT REQUIREMENTS)

1. **Initial Page Request**: Fetch initial page, extract session cookie and tokens from last `<script>` tag
2. **Token Extraction**: Extract tokens from last script tag only, NO fallback strategies
3. **Polling with Cookie Updates**: Use current cookies for request → extract cookies from response → update for next request
4. **Session State**: Track cookies across all polling requests, update after each response
5. **Token Source**: Extract tokens from `data` object in last script tag using `extractSessionData()` method only
6. **Required Tokens**: Must extract `_token`, `session`, `suuid`, and `deeplink` from initial page

#### Implementation Rules

- **No Fallbacks**: Use only specified token extraction methods
- **JavaScript Parsing**: Extract tokens from specific JavaScript objects/patterns
- **Cookie Flow**: Both Kiwi and Sky update cookies after each response for the next request
- **Request Headers**: Use identical headers across all requests
- **Error Handling**: Handle 419 errors, retry with fresh tokens, validate token presence
- **Debug-First**: Create debug scripts to analyze real website behavior, save responses for analysis

### Session Management Best Practices

```typescript
// Both Kiwi and Sky: Update cookies after each response
let currentCookies = initialResponseCookies;
for (let poll = 0; poll < maxPolls; poll++) {
  const response = await makePollRequest(currentCookies);
  currentCookies = extractCookiesFromResponse(response);
}
```

- **Token Extraction**: Extract ALL required tokens from initial page, never during polling
- **Cookie Flow**: Use initial page cookies for first request, then cookies from each response for subsequent requests
- **Session State**: Maintain session state across multiple requests with proper cookie updates
- **Response Headers**: Always extract and use Set-Cookie headers from responses
- **Multiple Cookies**: Parse multiple Set-Cookie headers and merge them properly
- **Debug-First**: Create comprehensive debug scripts to analyze real website behavior
- **Documentation-Driven**: Follow website documentation exactly for request/response patterns
- **Error Recovery**: Handle 419 "Page Expired" errors by ensuring proper token/cookie state
- **Request Headers**: Use consistent headers across all requests (User-Agent, Accept, etc.)
- **Rate Limiting**: Implement polite delays between polling requests (100ms intervals)

## Session Management Best Practices

```typescript
// Correct cookie flow implementation
let currentCookies = {};

// Initialize with cookies from initial page
if (initialPageCookie) {
  currentCookies.flightsfinder_session = initialPageCookie;
}

// For each polling request
for (let attempt = 0; attempt < maxAttempts; attempt++) {
  // Use current cookies for this request
  const response = await makeRequest(currentCookies);

  // Update cookies for next request with cookies from this response
  if (response.cookies) {
    currentCookies = { ...currentCookies, ...response.cookies };
  }
}
```

## Debugging Web Scrapers

- **HTML Analysis**: Save response HTML to debug files for analysis
- **Header Inspection**: Log and analyze all response headers
- **Token Validation**: Verify token extraction with multiple strategies
- **Cookie Tracking**: Track cookie changes across requests
- **Real Website Testing**: Always test against actual websites, not assumptions
- **Response Structure Analysis**: Understand the exact format of responses (7-part structure)
- **Error Pattern Recognition**: Identify common error patterns (419, missing tokens, etc.)

## Environment & Testing

- Test in Convex environment immediately
- Validate against real website responses
- Clear test data before each test run
- Document environment-specific issues

## Convex Development & Debugging

### Convex Environment Limitations

- **No File System Access**: Convex functions cannot write files directly
- **No Node.js APIs**: Many Node.js built-ins are not available in Convex
- **Limited Debugging Tools**: Traditional debugging methods may not work

### Debugging Strategy for Convex

- **Separate Debug Scripts**: Create standalone Node.js scripts outside of Convex for debugging
- **Convex Actions**: Use "use node" directive for operations that require Node.js APIs
- **Avoid Debug Code in Production**: Remove debug action calls from production code
- **Use Logging**: Leverage Convex's logging capabilities for runtime debugging

### Debugging Workflow

1. **Development Phase**: Use external debug scripts to analyze website behavior
2. **Testing Phase**: Use Convex actions for Node.js operations when needed
3. **Production Phase**: Remove debug action calls and rely on logging
4. **Troubleshooting**: Use external scripts to reproduce issues outside of Convex

### Common Convex Issues & Solutions

- **TypeScript Errors**: Debug action references may cause TypeScript errors - safely ignore if debug functionality is removed
- **Deployment Failures**: Node.js API usage in Convex functions causes deployment failures - use actions with "use node" directive
- **File Writing**: Cannot write files directly from Convex functions - use external scripts or Convex actions
- **Context Issues**: `ctx` parameter may cause type issues - handle gracefully or remove debug calls

### Convex Debugging Code Examples

```typescript
// ❌ Don't do this in production Convex functions
await ctx.runAction(api.debugActions.saveDebugFile, {
  filename: "debug.html",
  content: html,
});

// ✅ Instead, use logging and external debug scripts
autonomousDebugger.log("Debug info", "debug", { htmlLength: html.length });

// ✅ For Node.js operations, use Convex actions with "use node"
// convex/debugActions.ts
("use node");
import { action } from "./_generated/server";
import { v } from "convex/values";
import fs from "fs";

export const saveDebugFile = action({
  args: { filename: v.string(), content: v.string() },
  returns: v.null(),
  handler: async (ctx, args) => {
    fs.writeFileSync(`debug/${args.filename}`, args.content);
    return null;
  },
});
```

## Documentation Standards

- JSDoc: @param, @returns, @example, @throws
- Include error handling and performance notes
- Provide working examples for all APIs
- Update docs when code changes

## Error Handling

- Specific error types (NetworkError, ParsingError, etc.)
- Context in error messages (URL, duration, parameters)
- Safe defaults on failures
- Proper resource cleanup

## For Complete Guidelines

See `docs/IMPLEMENTATION_SUMMARY.md` for current status and `FLIGHT_SCRAPING_IMPLEMENTATION_PLAN.md` for detailed implementation.

## Deployment Policy

- Never deploy to production. Always deploy to dev for all deployment and testing operations. This applies to all Convex, backend, and frontend deployments, as well as any automated or manual deployment scripts.

## File Change Tracking

- **ALWAYS** list all files that were touched/modified when finishing changes
- Include both created and modified files in the summary
- Mention any files that were deleted if relevant
- Provide a clear summary of what was changed in each file
- This helps with code review, debugging, and project tracking -->
